#
# fist real test grammar for gerund detection
#
# ATTENTION: uses Linigpipe interpretatiom of Brown/Penn Tagset
#
# ATTENTION: sets with underscores are ment to be abstract concepts
#     which are independent from the tagset.
#

############################################################################# 
#
# Common definitions
#
############################################################################# 

DELIMITERS = "<.>" "<!>" "<?>" ; # sentence window

LIST _INGFORM = VBG HVG BEG ; # gerunds or present participle
LIST _INFIN = BE-INF DO-INF HV-INF VB-INF; # infinitives (introduced below)
LIST _ADVER = RB RBR RBT; 	#  some types of adverbs used with infinitives
LIST _NEG   = "<not>" "<Not>";  # negation words, TODO: contractions?!
LIST _ADJEC = JJ JJT JJS JJR;
LIST _NOUNS = NN NN$ NNS NNS$ NP NP$ NPS NPS$;

############################################################################# 
#
# Preprocessing: fixing tagger issues and introducing ambiguous readings
#
############################################################################# 

BEFORE-SECTIONS

# repair mistagged "to" before two or more adverbs 
LIST _UNINFLECTED = BE DO GV VB;
"<To>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINFLECTED BARRIER (*) - _ADVER );
"<to>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINFLECTED BARRIER (*) - _ADVER );


# introduce infinitive tags (Brown tagset only knows "uninflected forms")
SUBSTITUTE (BE) (BE-INF) (BE) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (DO) (DO-INF) (DO) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (HV) (HV-INF) (HV) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (VB) (VB-INF) (VB) (-1*C (TO) BARRIER (*) - _ADVER);

# append gerund reading to -ing forms
# this version would not keep the original tags
#APPEND ("" GERUND) _INGFORM;
#APPEND ("" PROGRE) _INGFORM;
#APPEND ("" PARTIC) _INGFORM;

# add readings for all -ing forms (this should be done in a smarter way)
# 
SUBSTITUTE ("" VBG) ("---remove---" VBG) (VBG);
APPEND ("" VBG GERU)   (VBG);
APPEND ("" HVG GERU)   (HVG);
APPEND ("" BEG GERU)   (BEG);
APPEND ("" VBG PROG)   (VBG);
APPEND ("" HVG PROG)   (HVG);
APPEND ("" BEG PROG)   (BEG);
APPEND ("" VBG PART)   (VBG);
APPEND ("" HVG PART)   (HVG);
APPEND ("" BEG PART)   (BEG);
# remove readings without  tags.
LIST X = GERU PROG PART;
REMOVE ("---remove---" VBG);

# add reading for going-to-future
"<going>" APPEND ("" VGB GOFU) (VBG);

# add reading for going-to-future in the past
"<going>" APPEND ("" VGB GOFUPA) (VBG);




############################################################################# 
#
# Rules: disambiguating -ing forms
#
############################################################################# 

SECTION

# -ing: going-to-future
# TOOD: questions
SELECT (GOFU) (-1* (BER) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEM) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);


# add reading for going-to-future in the past
# TOOD: questions
SELECT (GOFUPA) (-1* (BED)  BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFUPA) (-1* (BEDZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);


# -ing: select progressive form readings
# TOOD: questions
LIST _PROGINTRO = BEM BEZ BER BEN BE;
SELECT (PROG) (-1* _PROGINTRO BARRIER (*) - _NEG - _ADVER);

# -ing: select gerund readings
# TODO
# ... first easy rules for testing
SELECT (GERU) (-2 _ADVER) (-1 (IN));
SELECT (GERU) (-2 _ADVER) (-1 (CS));
SELECT (GERU) (-2 _ADJEC) (-1 (IN));
SELECT (GERU) (-2 _ADJEC) (-1 (CS));

# this will overgenerate?!
# TODO
SELECT (GERU) (-1 (IN));
SELECT (GERU) (-1 (CS));

# utility: definition of a noun phrase context including adjectives 
LIST NP_DETPREP = DT DTS DTI AT PP$ PP$$ PPL PPLS PPO PPS PPSS;
TEMPLATE DET_QL_AP_NP = (+1 NP_DETPREP LINK +1* (QL) BARRIER (*) - (QL) LINK +1* _ADJEC BARRIER (*) - _ADJEC LINK +1* _NOUNS BARRIER (*) - _NOUNS );
TEMPLATE DET_AP_NP    = (+1 NP_DETPREP LINK +1* _ADJEC BARRIER (*) - _ADJEC LINK +1* _NOUNS BARRIER (*) - _NOUNS );
TEMPLATE DET_NP       = (+1 NP_DETPREP LINK +1* _NOUNS BARRIER (*) - _NOUNS ) ;
TEMPLATE SIMPLE_NP    = (+1* _NOUNS BARRIER (*) - _NOUNS );
TEMPLATE NP_CONTEXT   = ( (T:DET_QL_AP_NP) OR  (T:DET_AP_NP) OR  (T:DET_NP) OR  (T:SIMPLE_NP)  );

# -ing: select participle readings
# TODO
# ... first easy rules for sentence initial participles
TEMPLATE COMMA_CONTEXT = ( +1 ("<,>") );

# Participle + Noun Phrase
SELECT (PART) (@1 (PART) LINK T:NP_CONTEXT LINK T:COMMA_CONTEXT );

# Participle + Prepositional Phrase including Noun Phrase. 
SELECT (PART) (@1 (PART) LINK +1 (IN) LINK T:NP_CONTEXT LINK T:COMMA_CONTEXT );



############################################################################# 
#
# After inferring the required information: marking of the chunks
#
############################################################################# 

AFTER-SECTIONS

# marking infinitive constructions: TO ADVER* INFIN
# INF-B: beginning of chunk. INF-I: inside of chunk.
ADD (INF-B) (TO)    (+*1C _INFIN BARRIER (*) - _ADVER ); 
ADD (INF-I) _INFIN (-*1C (TO) BARRIER (*) - _ADVER );
ADD (INF-I) _ADVER (-*1C (TO) BARRIER (*) - _ADVER ) (+*1C _INFIN BARRIER (*) - _ADVER );

# marking gerund constructions
ADD (GER-B) (GERU);


