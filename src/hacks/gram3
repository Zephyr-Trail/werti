#
# fist real test grammar for gerund detection
#
# ATTENTION: uses Linigpipe interpretatiom of Brown/Penn Tagset
#
# ATTENTION: sets and templates with underscores are meant to be used 
# globally in the entire section they are specified in.
#

############################################################################# 
#
# Common definitions
#
############################################################################# 

#----- HANDLING PUNCTUATION PROPERLY ----------------------------------------

# TODO: abbreviations are broken.

DELIMITERS = "<.>" "<!>" "<?>" ; # sentence window


#----- GLOBAL ABSTRACT SETS OF POS ------------------------------------------

LIST _INGFORM = VBG HVG BEG ; # gerunds or present participle
LIST _INFIN = BE-INF DO-INF HV-INF VB-INF; # to-infinitives (introduced below)
LIST _UNINF = BE DO GV VB;           # uninflected (infinitives or imperatives without to)
LIST _ADVER = RB RBR RBT; 	#  some types of adverbs used with infinitives
LIST _NEG   = "<not>" "<Not>";  # negation words, TODO: contractions?!
LIST _ADJEC = JJ JJT JJS JJR;
LIST _NOUNS = NN NN$ NNS NNS$ NP NP$ NPS NPS$;
LIST _ANYVERB_ANYFORM = VB VBD VBG VBN VBZ BE BED BEDZ BEG BEM BEN BER BEZ DO DOD DOZ HV HVD HVG HVN HVZ MD;

############################################################################# 
#
# Preprocessing: fixing tagger issues and introducing ambiguous readings
#
############################################################################# 

BEFORE-SECTIONS

# repair mistagged "to" before two or more adverbs 
"<To>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINF BARRIER (*) - _ADVER );
"<to>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINF BARRIER (*) - _ADVER );

# Introduce a new tag for double quotes. The tagset is missing this one. As the
# tagger does not know them, it produces all kinds of funny analyses instead.
APPEND ("" QUOT) ("<">");
APPEND ("" QUOT) ("<&quot;>");
SELECT (QUOT) (0 (QUOT));

# Simple sentence-initial question forms may have been assigned any
# funny tag.
APPEND ("" BEDZ) ("<Was>") (+1 (PPSS));
APPEND ("" BED)  ("<Were>")(+1 (PPSS));
APPEND ("" BEDZ) ("<was>") (+1 (PPSS));
APPEND ("" BED) ("<was>") (+1 (PPSS));

# 's contraction is always BEZ
APPEND ("" BEZ) ("<s>") (-1 ("<'>"));

# introduce infinitive tags (Brown tagset only knows "uninflected forms")
SUBSTITUTE (BE) (BE-INF) (BE) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (DO) (DO-INF) (DO) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (HV) (HV-INF) (HV) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (VB) (VB-INF) (VB) (-1*C (TO) BARRIER (*) - _ADVER);

# add readings for all -ing forms (this should be done in a smarter way)
# 
SUBSTITUTE ("" VBG) ("---remove---" VBG) (VBG);
APPEND ("" VBG GERU)   (VBG);
APPEND ("" HVG GERU)   (HVG);
APPEND ("" BEG GERU)   (BEG);
APPEND ("" VBG PROG)   (VBG);
APPEND ("" HVG PROG)   (HVG);
APPEND ("" BEG PROG)   (BEG);
APPEND ("" VBG PART)   (VBG);
APPEND ("" HVG PART)   (HVG);
APPEND ("" BEG PART)   (BEG);
# remove readings without  tags.
LIST X = GERU PROG PART;
REMOVE ("---remove---" VBG);

# add reading for going-to-future
"<going>" APPEND ("" VGB GOFU) (VBG);

# add reading for going-to-future in the past
"<going>" APPEND ("" VGB GOFUPA) (VBG);




############################################################################# 
#
# Rules: disambiguating -ing forms
#
############################################################################# 

SECTION

#----- UTILITY TEMPLATES AND LISTS/SETS -------------------------------------

# finite forms of to be, including imperative
LIST _BE_FINITE = BEM BEZ BER BEN BED BEDZ;

# utility: definition of a noun phrase context including adjectives
# and an adjective phrase 
LIST _NP_DETPREP = DT DTS DTI AT PP$ PP$$ PPL PPLS PPO PPS PPSS;
TEMPLATE ACC_PRON   = (+1 (PPO));
TEMPLATE SIMPLE_NP  = (+1 _NOUNS LINK T:SIMPLE_NP) OR (+1 _NOUNS);
TEMPLATE SIMPLE_AP  = (+1 _ADJEC LINK T:SIMPLE_AP) OR  (+1 _ADJEC);
TEMPLATE SIMPLE_QLP = (+1 (QL) LINK T:SIMPLE_QLP) OR  (+1 (QL));
TEMPLATE AP_NP  = (T:SIMPLE_AP LINK T:SIMPLE_NP);
TEMPLATE QL_AP_NP  = (T:SIMPLE_QLP LINK T:SIMPLE_AP LINK T:SIMPLE_NP);
TEMPLATE NP_CONTEXT_NODET   = ( (T:QL_AP_NP) OR (T:AP_NP) OR (T:SIMPLE_NP) ); 
TEMPLATE NP_CONTEXT_DET     = (+1 _NP_DETPREP LINK T:NP_CONTEXT_NODET );

# result of the above: a noun phrase context and an adjective phrase context.
TEMPLATE _NP_CONTEXT = ( (T:NP_CONTEXT_DET) OR  (T:NP_CONTEXT_NODET) OR (T:ACC_PRON) );
TEMPLATE _AP_CONTEXT = ( (T:SIMPLE_QLP LINK T:SIMPLE_AP) OR (T:SIMPLE_AP) );

# a context for a prepositional phrase with a noun phrase or just a noun phrase
TEMPLATE _NP_OR_PP_CONTEXT = ( (T:_NP_CONTEXT) OR (+1 (IN) LINK T:_NP_CONTEXT) );



#----- GOING-TO FUTURE AND FUTURE-IN-THE-PAST -------------------------------

# cluster of negation and adverbs as a context
#SET _ADVNEG = _ADVER + _NEG;
#TEMPLATE NAD_CLUSTER = (+1 _ADVNEG LINK T:NAD_CLUSTER) OR (+1 _ADVNEG);

# -ing: going-to-future
# sentences
SELECT (GOFU) (-1* (BER) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEM) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
# qestions
SELECT (GOFU) (-1* (BER) BARRIER _ANYVERB_ANYFORM) (+1 (TO)) (+2 _INFIN) (+3* ("<?>"));
SELECT (GOFU) (-1* (BEM) BARRIER _ANYVERB_ANYFORM) (+1 (TO)) (+2 _INFIN) (+3* ("<?>"));
SELECT (GOFU) (-1* (BEZ) BARRIER _ANYVERB_ANYFORM) (+1 (TO)) (+2 _INFIN) (+3* ("<?>"));

# add reading for going-to-future in the past
SELECT (GOFUPA) (-1* (BED)  BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFUPA) (-1* (BEDZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
# question
SELECT (GOFUPA) (-1* (BED) BARRIER _ANYVERB_ANYFORM) (+1 (TO)) (+2 _INFIN) (+3* ("<?>"));
SELECT (GOFUPA) (-1* (BEDZ) BARRIER _ANYVERB_ANYFORM) (+1 (TO)) (+2 _INFIN) (+3* ("<?>"));


#----- OTHER PROGRESSIVE FORM READINGS --------------------------------------

# sentence
SELECT (PROG) (-1* _BE_FINITE BARRIER (*) - _NEG - _ADVER);
# question
SELECT (PROG) (-1* _BE_FINITE BARRIER _ANYVERB_ANYFORM) (+1* ("<?>"));


#----- GERUND READINGS ------------------------------------------------------

# TODO
# ... first easy rules for testing
SELECT (GERU) (-2 _ADVER) (-1 (IN));
SELECT (GERU) (-2 _ADVER) (-1 (CS));
SELECT (GERU) (-2 _ADJEC) (-1 (IN));
SELECT (GERU) (-2 _ADJEC) (-1 (CS));

# this will overgenerate?!
# TODO
SELECT (GERU) (-1 (IN));
SELECT (GERU) (-1 (CS));

# select gerund after inflected verbs and optional noun in between
# FIXME doesn't work...
#SELECT (GERU) (-1C* (VBD OR VBZ) BARRIER (*) - (NN OR NP));

# gerund as directly preceding subject argument to the verb in 3rd person
# and/or past tense or will-future
LIST _3P_PRES = VBZ | BEZ | DOZ | VHZ;
LIST _3P_PAST = BEDZ DOD HVD VBD;
SELECT (GERU) (+1 _3P_PRES);
SELECT (GERU) (+1 _3P_PAST);
SELECT (GERU) (+1 (MD)) (+2 _UNINF);

# and the same with gerund + NP and gerund + PP(NP)
SELECT (GERU) (T:_NP_OR_PP_CONTEXT LINK +1 _3P_PRES);
SELECT (GERU) (T:_NP_OR_PP_CONTEXT LINK +1 _3P_PAST);
SELECT (GERU) (T:_NP_OR_PP_CONTEXT LINK +1 (MD) LINK +1 _UNINF);

# 'predicative gerund' such as "Being good is bad."
SELECT (GERU) (0 (BEG)) (T:_AP_CONTEXT);


#----- PARTICIPLE READINGS --------------------------------------------------

LIST _COMMA  = "<,>" "<;>";
LIST _COMMA_OR_SUBORD =  "<,>" "<;>" CS; 

# Participle + Noun Phrase
# or
# Participle + Prepositional Phrase including Noun Phrase. 
# at the sentence beginning
#SELECT (PART) (-1 (>>>)) (T:_NP_OR_PP_CONTEXT LINK +1 _COMMA_OR_SUBORD  );
# TODO: does this quite sledgehammery rule overgenerate??
SELECT (PART) (-1 (>>>)) (+1*  _COMMA_OR_SUBORD BARRIER _ANYVERB_ANYFORM );

# "... , she sitting on the seat beside him, ... "-parentheses
SELECT (PART) (-1* _COMMA BARRIER _ANYVERB_ANYFORM) (T:_NP_OR_PP_CONTEXT LINK +1* ( _COMMA_OR_SUBORD) BARRIER _ANYVERB_ANYFORM );
SELECT (PART) (-1* _COMMA BARRIER _ANYVERB_ANYFORM) (+1 _ADVER LINK T:_NP_OR_PP_CONTEXT LINK +1* _COMMA_OR_SUBORD  BARRIER _ANYVERB_ANYFORM );

# "... , not noticing the bit of sarcasm."
#SELECT (PART) (-1* _COMMA BARRIER _ANYVERB_ANYFORM) (T:_NP_OR_PP_CONTEXT LINK (+1* #_COMMA_OR_SUBORD BARRIER _ANYVERB_ANYFORM ) OR (+1* (<<<) BARRIER _ANYVERB_ANYFORM) ) ;
# "..., not noticing that..."
# TODO: does this overgenerate?
SELECT (PART) (-1* _COMMA BARRIER _ANYVERB_ANYFORM) ((+1* _COMMA_OR_SUBORD BARRIER _ANYVERB_ANYFORM ) OR (+1* (<<<) BARRIER _ANYVERB_ANYFORM)) ;

############################################################################# 
#
# After inferring the required information: marking of the chunks
#
############################################################################# 

AFTER-SECTIONS

# ATTENTION: since we do not want ambigous annotations to be marked,
# every constraint here must be careful (marked with C). This will
# ommit ambigous readings.

# marking infinitive constructions: TO ADVER* INFIN
# INF-B: beginning of chunk. INF-I: inside of chunk.
ADD (INF-B) (TO)    (+*1C _INFIN BARRIER (*) - _ADVER ); 
ADD (INF-I) _INFIN (-*1C (TO) BARRIER (*) - _ADVER );
ADD (INF-I) _ADVER (-*1C (TO) BARRIER (*) - _ADVER ) (+*1C _INFIN BARRIER (*) - _ADVER );

# marking gerund constructions
ADD (GER-B) (GERU) (0C (GERU));

# these are used for the debug option of showing all known ingforms
ADD (GOI-B) (GOFU) (0C (GOFU));
ADD (GOP-B) (GOFUPA) (0C (GOFUPA));
ADD (PRO-B) (PROG) (0C (PROG));
ADD (PAR-B) (PART) (0C (PART));

# and this marks the ones which are still ambiguous, ...
APPEND ("" AMB-B) (GERU) (NOT 0 (GER-B));
APPEND ("" AMB-B) (PROG) (NOT 0 (PRO-B)) (NOT 0 (AMB-B));
APPEND ("" AMB-B) (PART) (NOT 0 (PAR-B)) (NOT 0 (AMB-B));
APPEND ("" AMB-B) (GOFU) (NOT 0 (GOI-B)) (NOT 0 (AMB-B));
APPEND ("" AMB-B) (GOFUPA) (NOT 0 (GOP-B))  (NOT 0 (AMB-B));
# ... and then delete the rest (better comment out this during grammar development!)
SELECT  (AMB-B) (0 (AMB-B));
