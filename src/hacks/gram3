#
# fist real test grammar for gerund detection
#
# ATTENTION: uses Linigpipe interpretatiom of Brown/Penn Tagset
#
# ATTENTION: sets with underscores are ment to be abstract concepts
#     which are independent from the tagset.
#

############################################################################# 
#
# Common definitions
#
############################################################################# 

DELIMITERS = "<.>" "<!>" "<?>" ; # sentence window

LIST _INGFORM = VBG HVG BEG ; # gerunds or present participle
LIST _INFIN = BE-INF DO-INF HV-INF VB-INF; # infinitives (introduced below)
LIST _ADVER = RB RBR RBT; 	#  some types of adverbs used with infinitives
LIST _NEG   = "<not>" "<Not>";  # negation words, TODO: contractions?!
LIST _ADJEC = JJ JJT JJS JJR;
LIST _NOUNS = NN NN$ NNS NNS$ NP NP$ NPS NPS$;

############################################################################# 
#
# Preprocessing: fixing tagger issues and introducing ambiguous readings
#
############################################################################# 

BEFORE-SECTIONS

# repair mistagged "to" before two or more adverbs 
LIST _UNINFLECTED = BE DO GV VB;
"<To>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINFLECTED BARRIER (*) - _ADVER );
"<to>" SUBSTITUTE (IN) (TO) (IN) ( +1*C _UNINFLECTED BARRIER (*) - _ADVER );


# introduce infinitive tags (Brown tagset only knows "uninflected forms")
SUBSTITUTE (BE) (BE-INF) (BE) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (DO) (DO-INF) (DO) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (HV) (HV-INF) (HV) (-1*C (TO) BARRIER (*) - _ADVER);
SUBSTITUTE (VB) (VB-INF) (VB) (-1*C (TO) BARRIER (*) - _ADVER);

# append gerund reading to -ing forms
# this version would not keep the original tags
#APPEND ("" GERUND) _INGFORM;
#APPEND ("" PROGRE) _INGFORM;
#APPEND ("" PARTIC) _INGFORM;

# add readings for all -ing forms (this should be done in a smarter way)
# 
SUBSTITUTE ("" VBG) ("---remove---" VBG) (VBG);
APPEND ("" VBG GERU)   (VBG);
APPEND ("" HVG GERU)   (HVG);
APPEND ("" BEG GERU)   (BEG);
APPEND ("" VBG PROG)   (VBG);
APPEND ("" HVG PROG)   (HVG);
APPEND ("" BEG PROG)   (BEG);
APPEND ("" VBG PART)   (VBG);
APPEND ("" HVG PART)   (HVG);
APPEND ("" BEG PART)   (BEG);
# remove readings without  tags.
LIST X = GERU PROG PART;
REMOVE ("---remove---" VBG);

# add reading for going-to-future
"<going>" APPEND ("" VGB GOFU) (VBG);

# add reading for going-to-future in the past
"<going>" APPEND ("" VGB GOFUPA) (VBG);




############################################################################# 
#
# Rules: disambiguating -ing forms
#
############################################################################# 

SECTION

# -ing: going-to-future
# TOOD: questions
SELECT (GOFU) (-1* (BER) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEM) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFU) (-1* (BEZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);


# add reading for going-to-future in the past
# TOOD: questions
SELECT (GOFUPA) (-1* (BED)  BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);
SELECT (GOFUPA) (-1* (BEDZ) BARRIER (*) - _NEG - _ADVER) (+1 (TO)) (+2 _INFIN);


# -ing: select progressive form readings
# TOOD: questions
LIST _PROGINTRO = BEM BEZ BER BEN BE;
SELECT (PROG) (-1* _PROGINTRO BARRIER (*) - _NEG - _ADVER);

# -ing: select gerund readings
# TODO
# ... first easy rules for testing
SELECT (GERU) (-2 _ADVER) (-1 (IN));
SELECT (GERU) (-2 _ADVER) (-1 (CS));
SELECT (GERU) (-2 _ADJEC) (-1 (IN));
SELECT (GERU) (-2 _ADJEC) (-1 (CS));

# this will overgenerate?!
# TODO
SELECT (GERU) (-1 (IN));
SELECT (GERU) (-1 (CS));

# select gerund after inflected verbs and optional noun in between
# FIXME doesn't work...
SELECT (GERU) (-1C* (VBD OR VBZ) BARRIER (*) - (NN OR NP));

# utility: definition of a noun phrase context including adjectives 
LIST NP_DETPREP = DT DTS DTI AT PP$ PP$$ PPL PPLS PPO PPS PPSS;
TEMPLATE SIMPLE_NP  = (+1 _NOUNS LINK T:SIMPLE_NP) OR  (+1 _NOUNS);
TEMPLATE SIMPLE_AP  = (+1 _ADJEC LINK T:SIMPLE_AP) OR  (+1 _ADJEC);
TEMPLATE SIMPLE_QLP = (+1 (QL) LINK T:SIMPLE_QLP) OR  (+1 (QL));
TEMPLATE DET_NP     = (+1 NP_DETPREP LINK T:SIMPLE_NP );
TEMPLATE DET_AP_NP  = (+1 NP_DETPREP LINK T:SIMPLE_AP LINK T:SIMPLE_NP);
TEMPLATE DET_QL_AP_NP  = (+1 NP_DETPREP LINK T:SIMPLE_QLP LINK T:SIMPLE_AP LINK T:SIMPLE_NP);
TEMPLATE NP_CONTEXT   = ( (T:DET_QL_AP_NP) OR  (T:DET_AP_NP) OR  (T:DET_NP) OR (T:SIMPLE_NP) );


# -ing: select participle readings
# TODO
# ... first easy rules for sentence initial participles
TEMPLATE COMMA_CONTEXT = ( +1 ("<,>") );

# Participle + Noun Phrase
SELECT (PART) (-1 (<<<)) (T:NP_CONTEXT LINK T:COMMA_CONTEXT );

# Participle + Prepositional Phrase including Noun Phrase. 
SELECT (PART) (-1 (<<<)) (+1 (IN) LINK T:NP_CONTEXT LINK T:COMMA_CONTEXT);



############################################################################# 
#
# After inferring the required information: marking of the chunks
#
############################################################################# 

AFTER-SECTIONS

# ATTENTION: since we do not want ambigous annotations to be marked,
# every constraint here must be careful (marked with C). This will
# ommit ambigous readings.

# marking infinitive constructions: TO ADVER* INFIN
# INF-B: beginning of chunk. INF-I: inside of chunk.
ADD (INF-B) (TO)    (+*1C _INFIN BARRIER (*) - _ADVER ); 
ADD (INF-I) _INFIN (-*1C (TO) BARRIER (*) - _ADVER );
ADD (INF-I) _ADVER (-*1C (TO) BARRIER (*) - _ADVER ) (+*1C _INFIN BARRIER (*) - _ADVER );

# marking gerund constructions
ADD (GER-B) (GERU) (0C (GERU));

# these are used for the debug option of showing all known ingforms
ADD (GOI-B) (GOFU) (0C (GOFU));
ADD (GOP-B) (GOFUPA) (0C (GOFUPA));
ADD (PRO-B) (PROG) (0C (PROG));
ADD (PAR-B) (PART) (0C (PART));

# and this marks the ones which are still ambiguous
ADD (AMB-B) (GERU) (NOT 0 (GER-B)) (NOT 0 (GOI-B)) (NOT 0 (GOP-B)) (NOT 0 (PRO-B)) (NOT 0 (PAR-B))
ADD (AMB-B) (PROG) (NOT 0 (GER-B))(NOT 0 (GOI-B)) (NOT 0 (GOP-B)) (NOT 0 (PRO-B)) (NOT 0 (PAR-B))
ADD (AMB-B) (PART) (NOT 0 (GER-B))(NOT 0 (GOI-B)) (NOT 0 (GOP-B)) (NOT 0 (PRO-B)) (NOT 0 (PAR-B))
ADD (AMB-B) (GOFU) (NOT 0 (GER-B))(NOT 0 (GOI-B)) (NOT 0 (GOP-B)) (NOT 0 (PRO-B)) (NOT 0 (PAR-B))
ADD (AMB-B) (GOFUPA) (NOT 0 (GER-B)) (NOT 0 (GOI-B)) (NOT 0 (GOP-B)) (NOT 0 (PRO-B)) (NOT 0 (PAR-B))


